# JWT authorization

Токены предоставляют собой средство авторизации для каждого запроса от клиента к серверу. Токены(и соответственно сигнатура токена) генерируются на сервере основываясь на секретном ключе(который хранится на сервере) и payload'e. Токен в итоге хранится на клиенте и используется при необходимости авторизации какого-либо запроса.

Каждый токен имеет свой срок жизни, например access: 30 мин, refresh: 60 дней

## Access token

/login

1. Пользователь логинится в приложении, передавая логин/пароль и fingerprint браузера (ну или некий иной уникальный идентификатор устройства если это не браузер)
2. Сервер проверят подлинность логина/пароля
3. В случае удачи создает и записывает сессию в БД { userId: uuid, refreshToken: uuid, expiresIn: int, fingerprint: string, ... } (схема таблицы ниже)
4. Создает access token
5. Отправляет клиенту access и refresh token uuid (взятый из выше созданной сессии)
6. Клиент сохраняет токены(access в памяти приложения, refresh сетится как кука автоматом)

-   maxAge куки ставим равную expiresIn из выше созданной сессии
-   В path ставим корневой роут auth контроллера (/api/auth) это важно, таким образом токен получат только те хендлеры которым он нужен(/api/auth/logout и /api/auth/rerfesh-tokens), остальные обойдутся(нечего зря почём отправлять sensitive data).

-   Пользователь может иметь только 3 одновренно открытых сессии. Если пользователь будет логиниться под 4 сессией то сбросятся все кроме последней.

-   Перед каждым запросом клиент проверяет время жизни access token ( expiresIn ). Если истекло то шлем запрос на обновлние токенов.

## Refresh token

Роль рефреш токенов и зачем их хранить в БД. Рефреш на сервере хранится для учета доступа и инвалидации краденых токенов. Таким образом сервер наверняка знает о клиентах которым стоит доверять.

/refresh-tokens

1. Клиент(фронтенд) проверяет перед запросом не истекло ли время жизни access token'на
2. Если истекло клиент делает запрос на POST /refresh-tokens { fingerprint: string } в body и соответственно refreshToken куку.
3. Сервер получает запись рефреш-сессии по UUID'у рефреш токена
4. Сохраняет текущую рефреш-сессию в переменную и удаляет ее из таблицы
5. Проверяет текущую рефреш-сессию:

-   Не истекло ли время жизни
-   На соответствие старого fingerprint'a полученного из текущей рефреш-сессии с новым полученным из тела запроса

6. В случае негативного результата бросает ошибку TOKEN_EXPIRED/INVALID_REFRESH_SESSION
7. В случае успеха создает новую рефреш-сессию и записывает ее в БД
8. Создает access token
9. Отправляет клиенту access и refresh token uuid (взятый из выше созданной рефреш-сессии)

/logout

Безопасность

В случае кражи access токена и refresh куки:

Хакер воспользовался access token'ом
Закончилось время жизни access token'на
Клиент хакера отправляет refresh token и fingerprint
Сервер смотрит fingerprint хакера
Сервер не находит fingerprint хакера в рефреш-сессии и удаляет ее из БД
Сервер логирует попытку несанкционированного обновления токенов
Сервер перенаправляет хакера на станицу логина. Хакер идет лесом
Юзер пробует зайти на сервер >> обнаруживается что refresh token отсутствует
Сервер перенаправляет юзера на форму аутентификации
Юзер вводит логин/пароль

Thanks a lot - https://gist.github.com/zmts
